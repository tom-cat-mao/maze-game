# 算法驱动的迷宫探险游戏 (Algorithm-Driven Maze Adventure)

这是一个基于 Python FastAPI 和 Vue.js 的全栈 Web 应用，它不仅是一个游戏，更是一个**可交互的算法竞技场**。在这里，经典算法不再是抽象的代码，而是拥有不同“性格”和“策略”的鲜活角色，在一个动态生成的迷宫中展开对决。

## 设计哲学：算法即角色

本项目的核心思想是将不同的算法“拟人化”，赋予它们独特的决策模式，并通过可视化手段直观地展示它们在解决同一问题时的“思维过程”和最终效果差异。

-   **“深谋远虑的战略家”**: 树状动态规划（Tree DP）算法，它总能从全局出发，牺牲眼前利益，以换取最终的最高回报。
-   **“精打细算的投机者”**: 启发式贪心算法（Heuristic Greedy），它目光“短浅”，永远追求当前性价比最高的选择，展示了局部最优与全局最优的经典冲突。

通过观察和对比，用户可以更深刻地理解算法的本质特性、适用场景以及时空复杂度的权衡。

## 核心功能

-   **动态迷宫生成**: 基于**递归分割 (Recursive Division)** 算法，每次都能创造出结构独特、有唯一解的复杂迷宫。
-   **两种寻路算法对决**:
    -   **树状动态规划 (Tree DP)**: 保证找到全局最优路径，实现得分最大化。
    -   **启发式贪心 + A\***: 模拟“短视”决策，在每个节点寻找局部最优解。
-   **算法过程可视化**: 清晰地在前端界面上渲染出不同算法规划的路径，并对比其最终得分。
-   **互动游戏元素**:
    -   **谜题系统**: 采用**回溯法 (Backtracking)** 实时解决游戏内的密码锁谜题。
    -   **BOSS 战模拟**: 采用**分支限界法 (Branch and Bound)** 计算出最高效的战斗策略。
-   **手动探索模式**: 玩家可以亲自下场，用自己的“算法”挑战迷宫。

## 技术栈

-   **后端**: Python 3, FastAPI, Uvicorn
-   **前端**: Vue.js 3 (Composition API), Vite, Pinia, Axios
-   **测试**: Pytest

## 项目结构

```
/maze-adventure-game/
├── /backend/
│   ├── /app/
│   │   ├── /algorithms/  # 核心算法实现
│   │   ├── /api/         # API 路由
│   │   └── /models/      # Pydantic 数据模型
│   ├── /tests/           # 单元测试
│   └── requirements.txt
└── /frontend/
    ├── /src/
    │   ├── /components/  # Vue 组件
    │   ├── /services/    # API 服务
    │   ├── /store/       # Pinia 状态管理
    │   └── /views/       # 页面视图
    └── package.json
```

## 安装与运行

### 环境要求

-   Node.js (v16+)
-   Python (v3.8+)

### 后端

1.  **进入目录**: `cd backend`
2.  **创建并激活虚拟环境**:
    ```bash
    # macOS/Linux
    python3 -m venv venv && source venv/bin/activate
    # Windows
    python -m venv venv && .\\venv\\Scripts\\activate
    ```
3.  **安装依赖**: `pip install -r requirements.txt`
4.  **启动服务**: `uvicorn app.main:app --reload` (运行于 `http://127.0.0.1:8000`)

### 前端

1.  **进入目录**: `cd frontend`
2.  **安装依赖**: `npm install`
3.  **启动服务**: `npm run dev` (运行于 `http://localhost:5173` 或其他端口)

### 访问

在浏览器中打开前端服务地址即可开始游戏。

## 游戏玩法

### 目标

通过收集资源、解决谜题、挑战 BOSS，在迷宫中获得尽可能高的分数，并最终到达终点 `E`。

### 操作

-   **生成迷宫**: 点击 **"Generate Maze"** 按钮。
-   **手动移动**: 使用键盘的 **上、下、左、右箭头键** 控制玩家（蓝色圆点）。

### 迷宫图例

-   `S`: **起点**
-   `E`: **终点** (价值: +5)
-   `💰 (G)`: **金币** (价值: +10)
-   `🔥 (T)`: **陷阱** (价值: -5)
-   `🔧 (L)`: **机关/谜题** (价值: +5, 触发回溯算法解密)
-   `👹 (B)`: **BOSS** (价值: +10, 触发分支限界算法计算最优策略)

### 算法对决

-   点击 **"Solve with DP"**: **金色**路径展示“战略家”的全局最优解。
-   点击 **"Solve with Greedy"**: **蓝色**路径展示“投机者”的局部最优解。

## 核心算法深度解析

### 1. 迷宫生成：递归分割 (Recursive Division)

这是一种“建墙”而非“挖路”的算法，其特性对整个游戏体验至关重要。

-   **核心思想**: 从一个空旷的房间开始，随机选择水平或垂直方向建一堵墙，将空间一分为二。然后，在这堵墙上开一个门。对分割出的两个子空间递归地重复此过程，直到所有空间都被细分。
-   **项目中的意义**:
    -   **唯一解保证**: 该算法生成的迷宫从起点到终点有且仅有一条主路径，确保了游戏的“可解性”。
    -   **结构化布局**: 它创造了大量长廊和死胡同，为寻路算法提供了富有挑战性的“分支”结构，非常适合用来对比 DP 和贪心策略。
    -   **策略性放置**: 游戏元素的放置与迷宫生成过程相配合，确保了高价值物品往往位于需要“绕远路”的死胡同中，从而放大了不同寻路算法的策略差异。

### 2. 寻路算法：战略家 vs 投机者

#### 树状动态规划 (Tree DP) - “深谋远虑的战略家”

为迷宫寻宝问题量身定制的高效全局最优算法。

-   **核心思想**: 将复杂的迷宫问题分解为“主干”和“分支”。首先，用 BFS 找到 S 到 E 的最短路径作为“主干”。然后，从终点 E 沿着主干反向推导至起点 S。
-   **实现方式**: 在反向推导的每一步，算法都会计算从当前主干节点出发，探索所有“分支”路径并返回所能获得的“最大分支净收益”。一个节点的总价值 = 自身价值 + 分支收益 + 下一节点的总价值。这完美体现了 DP 的“最优子结构”特性。
-   **目的**: 保证找到一条无可争议的、总分最高的全域最优路径，作为评估其他策略的“黄金标准”。

#### 启发式贪心 + A\* (Heuristic Greedy with A\*) - “精打细算的投机者”

一个模拟“短视”决策的算法，由高层贪心策略和底层 A\* 寻路构成。

-   **核心思想**: 在任何位置，算法都会评估所有未拾取的宝藏，并选择一个“性价比”最高的（价值 / 距离）作为当前目标。它只关注眼前的最大利益，而不考虑这个决策对未来的影响。
-   **实现方式**: 一旦贪心策略确定了下一个目标，便会调用高效的 A\* 算法来计算并执行到该目标的最短路径。A\* 保证了“怎么去”是最高效的，但贪心策略决定了“去哪里”是短视的。
-   **目的**: 作为与 DP 算法的对照组，清晰地展示“局部最优”与“全局最优”之间的差异，揭示贪心策略的优势（决策快）与劣势（可能错失全局最优解）。

### 3. 游戏内事件解法

#### 回溯法 (Backtracking) - 密码谜题

-   **核心思想**: 系统性地、穷举式地搜索解空间。它从第一位密码开始，一位一位地尝试所有可能的数字。如果当前数字不满足约束条件，就“回溯”到上一位，尝试下一个可能；如果满足，就继续“前进”到下一位，直到找到完整解。

#### 分支限界法 (Branch and Bound) - BOSS 战

-   **核心思想**: 一种优化的穷举搜索。它将所有可能的技能组合想象成一棵巨大的决策树，然后通过设置一个“限界”（如“造成的伤害已经不如已知的最优策略”），聪明地“剪掉”那些没有前途的“树枝”，从而显著减少搜索空间，快速找到最优解。
