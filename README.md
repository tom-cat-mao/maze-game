# 算法驱动的迷宫探险游戏 (Algorithm-Driven Maze Adventure)

这是一个基于Python FastAPI和Vue.js的全栈Web应用项目，旨在动态生成和求解迷宫，并以可视化的方式展示和对比不同的经典计算机算法。

## 核心功能

- **动态迷宫生成**: 基于Prim算法和随机“破壁”策略，生成带有环路的复杂迷宫，确保每次游戏都有新体验。
- **玩家手动探索**: 支持使用键盘方向键在迷宫中自由移动。
- **寻路算法可视化**:
    -   **树状动态规划 (Tree DP)**: 通过将迷宫解构为“主干道”与“分支”，实现一种高效的动态规划。它会“深思熟虑”，计算并保证找到一条全局最优的、总价值最高的路径。
    -   **启发式贪心算法 (Heuristic Greedy)**: 模拟一种“短视”的决策模式。在每一步，它会贪婪地选择当前“性价比”最高的宝物作为目标，并使用A*算法前往。该策略旨在与DP算法形成鲜明对比。
- **动态谜题系统**:
    - **回溯法 (Backtracking)**: 玩家在接触“机关(L)”时，会触发一个随机生成的密码谜题，并由后端实时求解。
- **BOSS战模拟**:
    - **分支限界法 (Branch and Bound)**: 玩家在遭遇“BOSS(B)”时，可由后端计算出最优的技能释放顺序。
- **计分系统**: 根据玩家收集的资源和完成的事件进行计分。

## 技术栈

- **后端**: Python 3, FastAPI, Uvicorn
- **前端**: Vue.js 3 (Composition API), Vite, Pinia, Axios
- **测试**: Pytest

## 项目结构

```
/maze-adventure-game/
├── /backend/
│   ├── /app/
│   │   ├── /algorithms/
│   │   ├── /api/
│   │   └── /models/
│   ├── /tests/
│   └── requirements.txt
└── /frontend/
    ├── /src/
    │   ├── /assets/
    │   ├── /components/
    │   ├── /services/
    │   ├── /store/
    │   └── /views/
    └── package.json
```

## 安装与配置指南

### 环境要求
- Node.js (v16+)
- Python (v3.8+)

### 后端配置
1.  **进入后端目录**: `cd backend`
2.  **创建并激活虚拟环境**:
    -   macOS/Linux:
        ```bash
        python3 -m venv venv
        source venv/bin/activate
        ```
    -   Windows:
        ```bash
        python -m venv venv
        .\venv\Scripts\activate
        ```
3.  **安装依赖**:
    ```bash
    pip install -r requirements.txt
    ```

### 前端配置
1.  进入 `frontend` 目录: `cd frontend`
2.  安装依赖: `npm install`

## 如何运行

1.  **启动后端服务** (在项目根目录的 `backend` 文件夹下):
    ```bash
    cd backend
    uvicorn app.main:app --reload
    ```
    服务将运行在 `http://127.0.0.1:8000`。

2.  **启动前端服务** (在另一个终端中):
    ```bash
    cd frontend
    npm run dev
    ```
    服务将运行在 `http://localhost:5173` (或Vite提示的其他可用端口)。

3.  **访问应用**: 在浏览器中打开 `http://localhost:5173`。

## 游戏玩法

### 游戏目标
探索迷宫，通过收集资源、解决谜题、挑战BOSS来获得尽可能高的分数，并最终到达终点。

### 基本操作
-   点击 **"Generate Maze"** 按钮来创建一个新的随机迷宫。
-   使用键盘的 **上、下、左、右箭头键** 来控制玩家（蓝色圆点）在迷宫中移动。

### 迷宫元素图例
-   `S`: 你的**起点**。
-   `E`: **终点**，到达终点获得5分，游戏胜利。
-   `💰 (G)`: **金币**，踩中获得10分。
-   `🔥 (T)`: **陷阱**，踩中扣5分。
-   `🔧 (L)`: **机关/谜题**，踩中获得5分，并自动为你解开一个随机生成的密码谜题。
-   `👹 (B)`: **BOSS**，踩中获得10分，并自动为你计算出击败它的最优技能序列。

### 算法可视化
-   点击 **"Solve with DP"** 按钮，会以**金色**高亮显示出“树状动态规划”找到的全局最优路径。
-   点击 **"Solve with Greedy"** 按钮，会以**蓝色**高亮显示出“启发式贪心算法”找到的路径。
-   你可以对比两条路径的差异以及它们最终的得分。

## 核心算法简介

1.  **迷宫生成 (Prim + Wall Breaking)**: 首先用Prim算法生成一个只有唯一路径的“完美迷宫”，然后随机打穿几面墙，在迷宫中制造出环路和多种选择。

2.  **树状动态规划 (Tree DP)**: 一种为迷宫寻宝问题量身定制的高效全局最优算法。
    -   **核心思想**: 它将复杂的迷宫问题分解为“主干”和“分支”。首先，用BFS找到S到E的最短路径作为“主干”。然后，从终点E沿着主干反向推导至起点S。
    -   **实现方式**: 在反向推导的每一步，算法都会计算从当前主干节点出发，探索所有“分支”路径并返回所能获得的“最大分支净收益”。一个节点的总价值 = 自身价值 + 分支收益 + 下一节点的总价值。这完美体现了DP的“最优子结构”特性。
    -   **目的**: 保证找到一条无可争议的、总分最高的全域最优路径。

3.  **启发式贪心算法 (Heuristic Greedy with A*)**: 一个模拟“短视”决策的算法，由高层贪心策略和底层A*寻路构成。
    -   **核心思想**: 在任何位置，算法都会评估所有未拾取的宝藏，并选择一个“性价比”最高的（价值/距离）作为当前目标。它只关注眼前的最大利益，而不考虑这个决策对未来的影响。
    -   **实现方式**: 一旦贪心策略确定了下一个目标，便会调用高效的A*算法来计算并执行到该目标的最短路径。A*保证了“怎么去”是最高效的，但贪心策略决定了“去哪里”是短视的。
    -   **目的**: 作为与DP算法的对照组，清晰地展示“局部最优”与“全局最优”之间的差异。

4.  **回溯法 (Backtracking)**: 用于解决密码谜题。它会从第一位密码开始，一位一位地尝试所有可能的数字，如果当前数字不满足约束条件（如“必须是奇数”），它就放弃这个数字并尝试下一个；如果满足，就继续尝试下一位密码，直到找到完整的解。

5.  **分支限界法 (Branch and Bound)**: 用于计算BOSS战的最优策略。它会把所有可能的技能组合想象成一棵巨大的决策树，然后聪明地剪掉那些“一看就不划算”的树枝（比如连续使用一个低伤害技能），从而快速找到用最少回合击败BOSS的技能序列。
